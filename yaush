#include <stdio.h>
#include <pwd.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <readline/.h>

#define max 1024

struct passwd *pwd;
char *buffer;

void yaush(void);
void display_on_screen(char *prompt);
int read_order(char **order,char **para,char *prompt);


int main(){

	yaush();
	return 0;
}

void yaush(void){
	
	char prompt[1024];
	char *order = NULL;
	int panum,i;
	char **para;
	pid_t pid;

	para = malloc(sizeof(char *)*22);
	buffer = malloc(sizeof(char) * 4096);

	if(para == NULL || buffer == NULL){
		printf("malloc error.\n");
		return ;
	}

	while(1){
		display_on_screen(prompt);//shell 的前缀
		panum = read_order(&order,para,prompt);
		
		if(panum == -1){
			continue;
		}

		if((pid = fork()) > 0){//主进程
			//printf("fu jin chneg\n");
			wait(pid,NULL,0);

		}

		else{//zi jin cheng
			i=execvp(order,para);
			if(i=-1){
				printf("未找到命令\n");			
			}
			
			exit(0);
		}
	}
}

int read_order(char **order,char **para,char *prompt){
	char *buffer;
	char *p;
	
	free(buffer);

	//rl_attlempted_completion_fuction = cmdCompletion;
	//get_begidx();
	buffer = readline(prompt);
	add_history(buffer);//
	if(feof(stdin)!=0){
		printf("\n");
		exit(0);
	}
	
	if(buffer[0] == '\0') { 
		//printf("buffer is NULL"); 
		return -1;//输入为空
	}
	
	int i;
	//for(i=0;i<10;i++){printf("%d %c",buffer[i],buffer[i]);}
	
	char *ps,*pe;//每两个空格之间单词的头尾指针
	int flag=0;//表示是否完成了对输入的命令进行划分
	int count=0;
	ps=pe=buffer;

	while(flag==0){
		//printf("\n1\n");
		while(*ps == ' ' || *ps == '\t'){//排除输入的空格
			ps++;
			pe++;
		}

		if(*pe == '\0' || *pe == '\n'){
			if(count == 0)
				return -1;
			break;
		}

		while(*pe != ' ' && *pe != '\0' && *pe != '\n')//在两个空格之间查找单词
			*pe++;
		//printf("%c\n",pe[]);

		if(count == 0){
			p=pe;
			//printf("%d \n",*p);
			*order = ps;
			//printf("%d \n",*ps);		
			while(p != ps && *p != '/')
				p--;

			//printf("%d \n",*p);

			if(*p == '/')
				p++;

			para[0] = p;
			//printf("%d \n",*p);
			count = count+2;

		}
		else if(count<=20){
			para[count-1] = ps;
			count++;
		}
		else{
			break;	
		}

		
		if(*pe == '\0' || *pe == '\n'){
			*pe = '\0';
			flag = 1;
		}
		else{
			*pe = '\0';
			pe++;
			ps = pe;
		}

	}

	para[count-1] = NULL;//execvp最后一位必须为空

	//printf("%s\n",*order);
	//for(i=0;i<3;i++){printf("%s\n",para[i]);}
	//printf("%d \n",count);
	return count;
}

void display_on_screen(char *prompt){// [yaush]用户@主机名：路径$
	extern struct passwd *pwd;
	char hostname[256];
	char pathname[1024];
	int l;
	pwd =getpwuid(getuid());//用户名
	getcwd(pathname,1024);//路径

	if(gethostname(hostname,256)==0)//获得用户名和主机名
		sprintf(prompt,"[yaush]%s@%s:",pwd->pw_name,hostname);
	else
		sprintf(prompt,"[yaush]%s@unknown:",pwd->pw_name);

	l = strlen(prompt);

	if(strlen(pathname) < strlen(pwd->pw_dir) || strncmp(pathname,pwd->pw_dir,
	   strlen(pwd->pw_dir))!=0)//获得路径
		sprintf(prompt+l,"%s",pathname);//此目录为home目录，home路径不省略
	else
		sprintf(prompt+l,"~%s",pathname+strlen(pwd->pw_dir));//省略home路径

	l=strlen(prompt);

	if(geteuid() == 0)//检查是否是root
		sprintf(prompt+l,"# ");//root
	else
		sprintf(prompt+l,"$ ");//comm
	//puts(pwd->pw_dir); /home/linzq18/homework/big_homework
	//puts(pathname);  /home/linzq18
	//puts(prompt);

	return ;
}
