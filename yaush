#include <stdio.h>
#include <pwd.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define max 1024

#define BACK 1
#define IN_DIR 2
#define OUT_DIR 4
#define OUT_DIR_ADD 8
#define PIPE 16
struct analyze_info{
	int flag;
	char* in_file;
	char* out_file;
	char** para2;
	char* order2;
};

struct passwd *pwd;
char *buffer;
pid_t PID[max];//fujincheng

void yaush(void);
void display_on_screen(char *prompt);
int read_order(char **order,char **para,char *prompt);
int analyze_order(char **para,int panum,struct analyze_info *info);

int main(){
	int i;
	
	for(i=0;i<max;i++)
		PID[max] = 0;

	yaush();
	return 0;
}

void yaush(void){
	
	char prompt[1024];
	char *order = NULL;
	int panum,i;
	char **para;
	struct analyze_info info;
	pid_t pid1,pid2;

	para = malloc(sizeof(char *)*22);
	buffer = malloc(sizeof(char) * 4096);

	if(para == NULL || buffer == NULL){
		printf("malloc error.\n");
		return ;
	}

	while(1){
		int fd[2],out_fd,in_fd;
		display_on_screen(prompt);//shell 的前缀
		panum = read_order(&order,para,prompt);

		if(panum == -1){//未读到指令
			continue;
		}

		panum = panum - 1;//因为最后一位为NULL，所以要para-1

		analyze_order(para,panum,&info);//分析是否输入中有重定向和管道
		//printf("%d %d\n",info.flag,info.out_file);
		if( info.flag == PIPE){//判断是否有 pipe 指令，并生成管道
			if(pipe(fd)<0){
				printf("pipe error\n");
				exit(0);
			}
		}

		if((pid1 = fork()) > 0){//主进程
			//printf("fu jin chneg\n");
			if(info.flag == PIPE){
				if((pid2 = fork()) == 0){//pipe 执行|之后的命令
					close(fd[1]);
					close(STDIN_FILENO);
					dup2(fd[0],STDIN_FILENO);
					close(fd[0]);
					execvp(info.order2,info.para2);
				}
				else{//pid2的父进程
					close(fd[0]);
					close(fd[1]);
					wait(pid2,NULL,0);
					
				}

			}
			//printf("child finish\n");
			wait(pid1,NULL,0);

		}

		else{//子进程 order1 ，如果有|符号，只执行|符号之前的语句，并将结果送入管道里
			//printf("zi jin chneg\n");
			if(info .flag == PIPE){//处理管道符号之前的语句
				if(!(info.flag == OUT_DIR) && !(info.flag == OUT_DIR_ADD)){//pipe只起到链接作用
					close(fd[0]);
					close(STDOUT_FILENO);//关闭标准输出
					dup2(fd[1],STDOUT_FILENO);//将order1输出送入指向的管道fd[1]里，后面参数和前面参数指向一个地方
					close(fd[1]);
				}
				else{//管道 之前有文件相关操作
					close(fd[0]);
					close(fd[1]);
					if(info.flag == OUT_DIR){
						out_fd = open(info.out_file,O_WRONLY|O_CREAT|O_TRUNC,0666);
					}
					else{
						out_fd = open(info.out_file,O_WRONLY|O_APPEND|O_TRUNC,0666);

					}

					close(STDOUT_FILENO);
					dup2(out_fd,STDOUT_FILENO);
					close(out_fd);

				}			
			}
			else{//看是否重定向输出
				if(info.flag == OUT_DIR){//输出重定向
					out_fd = open(info.out_file,O_WRONLY|O_CREAT|O_TRUNC,0666);
					close(STDOUT_FILENO);
					dup2(out_fd,STDOUT_FILENO);
					close(out_fd);
				}
				if(info.flag == OUT_DIR_ADD){//输出重定向追加
					out_fd = open(info.out_file,O_WRONLY|O_CREAT|O_APPEND,0666);
					close(STDOUT_FILENO);
					dup2(out_fd,STDOUT_FILENO);
					close(out_fd);
				}
				if(info.flag == IN_DIR){//输入重定向
				in_fd = open(info.in_file,O_CREAT|O_RDONLY,0666);
				close(STDIN_FILENO);
				dup2(in_fd,STDIN_FILENO);
				close(in_fd);
				}	

			}

			
			i=execvp(order,para);
			if(i=-1){
				printf("未找到命令，请重新输入\n");			
			}
			exit(0);
		}
	}
	free(para);
	free(buffer);
}



int analyze_order(char **para,int panum,struct analyze_info *info){
	char* p;
	int i;
	info->flag = 0;
	info->in_file = NULL;
	info->out_file = NULL;
	info->order2 = NULL;
	info->para2 = NULL;

	//if(strcmp(para[panum]))

	for(i=0;i<panum;){//在每一个para[i]中查找是否有重定向和管道的输入符
		if(strcmp ( para[i],"<<") == 0 ||strcmp ( para[i],"<" ) == 0){
			info->flag = IN_DIR;
			info->in_file = para[i+1];
			para[i] = NULL;
			i=i+2;
		}
		else if(strcmp(para[i],">") == 0){
			info->flag = OUT_DIR;//printf("you > \n");
			info->out_file = para[i+1];
			para[i] = NULL;
			i=i+2;
		}
		else if(strcmp(para[i],">>") == 0){
			info->flag = OUT_DIR_ADD;
			info->out_file = para[i+1];
			para[i] = NULL;
			i=i+2;
		}
		else if(strcmp(para[i],"|") == 0){

			info->flag = PIPE;
			para[i] = NULL;
			info -> order2 = para[i+1];
			info -> para2 = &para[i+1];

			for(p = info->para2[0] + strlen(info->para2[0]);p != &(info->para2[0][0]) 
				&& *p !='/';p--)//判断是否在管道 | 符号之后有/
				;

			if(*p == '/')
				p++;
			info->para2[0] = p;
			break;
		}
		else

		i++;

	}
	return 1;

}

int read_order(char **order,char **para,char *prompt){
	char *buffer;
	char *p;
	
	free(buffer);

	//rl_attlempted_completion_fuction = cmdCompletion;
	//get_begidx();
	buffer = readline(prompt);
	add_history(buffer);//
	if(feof(stdin)!=0){
		printf("\n");
		exit(0);
	}
	
	if(buffer[0] == '\0') { 
		//printf("buffer is NULL"); 
		return -1;//输入为空
	}
	
	int i;
	//for(i=0;i<10;i++){printf("%d %c",buffer[i],buffer[i]);}
	
	char *ps,*pe;//每两个空格之间单词的头尾指针
	int flag=0;//表示是否完成了对输入的命令进行划分
	int count=0;
	ps=pe=buffer;

	while(flag==0){
		//printf("\n1\n");
		while(*ps == ' ' || *ps == '\t'){//排除输入的空格
			ps++;
			pe++;
		}

		if(*pe == '\0' || *pe == '\n'){
			if(count == 0)
				return -1;
			break;
		}

		while(*pe != ' ' && *pe != '\0' && *pe != '\n')//在两个空格之间查找单词
			*pe++;
		//printf("%c\n",pe[]);

		if(count == 0){
			p=pe;
			//printf("%d \n",*p);
			*order = ps;
			//printf("%d \n",*ps);		
			while(p != ps && *p != '/')
				p--;

			//printf("%d \n",*p);

			if(*p == '/')
				p++;

			para[0] = p;
			//printf("%d \n",*p);
			count = count+2;

		}
		else if(count<=20){
			para[count-1] = ps;
			count++;
		}
		else{
			break;	
		}

		
		if(*pe == '\0' || *pe == '\n'){
			*pe = '\0';
			flag = 1;
		}
		else{
			*pe = '\0';
			pe++;
			ps = pe;
		}

	}
//printf("%d \n",count);
	para[count-1] = NULL;//execvp zui hou yi wei bi xu wei kong
//	printf("%s\n",*order);
	//for(i=0;i<count-1;i++){printf("%s\n",para[i]);}
//	printf("%d \n",count);
	return count;
}

void display_on_screen(char *prompt){// [yaush]用户@主机名：路径$
	extern struct passwd *pwd;
	char hostname[256];
	char pathname[1024];
	int l;
	pwd =getpwuid(getuid());//用户名
	getcwd(pathname,1024);//路径

	if(gethostname(hostname,256)==0)//获得用户名和主机名
		sprintf(prompt,"[yaush]%s@%s:",pwd->pw_name,hostname);
	else
		sprintf(prompt,"[yaush]%s@unknown:",pwd->pw_name);

	l = strlen(prompt);

	if(strlen(pathname) < strlen(pwd->pw_dir) || strncmp(pathname,pwd->pw_dir,
	   strlen(pwd->pw_dir))!=0)//获得路径
		sprintf(prompt+l,"%s",pathname);//此目录为home目录，home路径不省略
	else
		sprintf(prompt+l,"~%s",pathname+strlen(pwd->pw_dir));//省略home路径

	l=strlen(prompt);

	if(geteuid() == 0)//检查是否是root
		sprintf(prompt+l,"# ");//root
	else
		sprintf(prompt+l,"$ ");//comm
	//puts(pwd->pw_dir); /home/linzq18/homework/big_homework
	//puts(pathname);  /home/linzq18
	//puts(prompt);

	return ;
}
