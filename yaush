#include <stdio.h>
#include <pwd.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <readline/.h>

#define max 1024

struct passwd *pwd;
char *buffer;


void yaush(void);
void display_on_screen(char *prompt);
int read_order(char **order,char **para,char *prompt);


int main(){
	
	yaush();
	return 0;
}

void yaush(void){
	
	char prompt[1024];
	char *order = NULL;
	int panum,i;
	char **para;
	struct analyze_info info;
	pid_t pid;

	para = malloc(sizeof(char *)*22);
	buffer = malloc(sizeof(char) * 4096);

	if(para == NULL || buffer == NULL){
		printf("malloc error.\n");
		return ;
	}

	while(1){
		int fd[2];
		display_on_screen(prompt);//shell 的前缀
		panum = read_order(&order,para,prompt);

		if(panum == -1){//未读到指令
			continue;
		}

		para = para - 1;
		analyze_order(para,panum,&info);//分析是否输入中有重定向和管道
		
		if( info.flag == PIPE){//sheng cheng pipe
			if(pipe(fd)<0){
				printf("pipe error\n");
				exit(0);
			}
		}
		
		

		if((pid = fork()) > 0){//主进程
			//printf("fu jin chneg\n");
			wait(pid,NULL,0);

		}

		else{//子进程
			i=execvp(order,para);
			if(i=-1){
				printf("未找到命令，请重新输入\n");			
			}
			
			exit(0);
		}
	}
}



void analyze_order(char **para,int panum,analyze_info *info){
	char* p;
	int i;
	info -> flag = NULL;
	info -> in_file = NULL;
	info -> out_file = NULL;
	info -> order2 = NULL;
	info ->para2 = NULL;

	if(strcmp(para[paunm]))

	for(i=0;i<para;){//在每一个para[i]中查找是否有重定向和管道的输入符
		if(strcmp ( para[i],"<<") == 0) ||strcmp ( para[i],"<" ) == 0){
			info->flag = IN_DIR;
			info->in_file = para[i+1];
			para[i] = NULL;
			i=i+2;
		}
		else if(strcmp(para[i],">") == 0){
			info->flag = OUT_DIR;
			info->in_file = para[i+1];
			para[i] = NULL;
			i=i+2;
		}
		else if(strcmp(para[i],">>") == 0){
			info->flag = OUT_DIR_ADD;
			info->in_file = para[i+1];
			para[i] = NULL;
			i=i+2;
		}
		else if(strcmp(para[i],"|") == 0){

			info->flag = PIPE;
			para[i] = NULL;
			info -> order2 = para[i+1];
			info ->para2 = &para[i+1];

			for(p = info->para2[0] + strlen(info->para2[0]);p != &(info->para[0][0]) 
				&& *p !='/';p--)//判断是否在管道 | 符号之后有/
				;

			if(p == '/')
				p++;
			info->para[0] = p;
			break;
		}
		else

		i++;

	}
	return 1;

}

int read_order(char **order,char **para,char *prompt){
	char *buffer;
	char *p;
	
	free(buffer);

	//rl_attlempted_completion_fuction = cmdCompletion;
	//get_begidx();
	buffer = readline(prompt);
	add_history(buffer);//
	if(feof(stdin)!=0){
		printf("\n");
		exit(0);
	}
	
	if(buffer[0] == '\0') { 
		//printf("buffer is NULL"); 
		return -1;//输入为空
	}
	
	int i;
	//for(i=0;i<10;i++){printf("%d %c",buffer[i],buffer[i]);}
	
	char *ps,*pe;//每两个空格之间单词的头尾指针
	int flag=0;//表示是否完成了对输入的命令进行划分
	int count=0;
	ps=pe=buffer;

	while(flag==0){
		//printf("\n1\n");
		while(*ps == ' ' || *ps == '\t'){//排除输入的空格
			ps++;
			pe++;
		}

		if(*pe == '\0' || *pe == '\n'){
			if(count == 0)
				return -1;
			break;
		}

		while(*pe != ' ' && *pe != '\0' && *pe != '\n')//在两个空格之间查找单词
			*pe++;
		//printf("%c\n",pe[]);

		if(count == 0){
			p=pe;
			//printf("%d \n",*p);
			*order = ps;
			//printf("%d \n",*ps);		
			while(p != ps && *p != '/')
				p--;

			//printf("%d \n",*p);

			if(*p == '/')
				p++;

			para[0] = p;
			//printf("%d \n",*p);
			count = count+2;

		}
		else if(count<=20){
			para[count-1] = ps;
			count++;
		}
		else{
			break;	
		}

		
		if(*pe == '\0' || *pe == '\n'){
			*pe = '\0';
			flag = 1;
		}
		else{
			*pe = '\0';
			pe++;
			ps = pe;
		}

	}

	para[count-1] = NULL;//execvp zui hou yi wei bi xu wei kong

	//printf("%s\n",*order);
	//for(i=0;i<3;i++){printf("%s\n",para[i]);}
	//printf("%d \n",count);
	return count;
}

void display_on_screen(char *prompt){// [yaush]用户@主机名：路径$
	extern struct passwd *pwd;
	char hostname[256];
	char pathname[1024];
	int l;
	pwd =getpwuid(getuid());//用户名
	getcwd(pathname,1024);//路径

	if(gethostname(hostname,256)==0)//获得用户名和主机名
		sprintf(prompt,"[yaush]%s@%s:",pwd->pw_name,hostname);
	else
		sprintf(prompt,"[yaush]%s@unknown:",pwd->pw_name);

	l = strlen(prompt);

	if(strlen(pathname) < strlen(pwd->pw_dir) || strncmp(pathname,pwd->pw_dir,
	   strlen(pwd->pw_dir))!=0)//获得路径
		sprintf(prompt+l,"%s",pathname);//此目录为home目录，home路径不省略
	else
		sprintf(prompt+l,"~%s",pathname+strlen(pwd->pw_dir));//省略home路径

	l=strlen(prompt);

	if(geteuid() == 0)//检查是否是root
		sprintf(prompt+l,"# ");//root
	else
		sprintf(prompt+l,"$ ");//comm
	//puts(pwd->pw_dir); /home/linzq18/homework/big_homework
	//puts(pathname);  /home/linzq18
	//puts(prompt);

	return ;
}
